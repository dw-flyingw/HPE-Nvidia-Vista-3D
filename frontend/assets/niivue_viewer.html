<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <style>
        body, html { margin: 0; padding: 0; width: 100%; height: 100%; overflow: hidden; }
        #niivue-canvas { width: 100%; height: 100%; display: block; pointer-events: auto; }
    </style>
</head>
<body>
    <canvas id="niivue-canvas"></canvas>
    <script>{{ niivue_lib_content|safe }}</script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pako/2.1.0/pako.min.js"></script>
    <script src="/utils/colormap_manager.js"></script>
    <script>
        if (typeof niivue === 'undefined') {
            console.error('Niivue library not loaded!');
        } else {
            console.log('NiiVue library loaded successfully');

            const nv = new niivue.Niivue({
                isColorbar: false,
                loadingText: 'loading ...',
                dragAndDropEnabled: false,
                isResizeCanvas: true,
                crosshairWidth: 1,
                crosshairColor: [1, 0, 0, 1],
                backColor: [0, 0, 0, 1]
            });
            nv.attachTo('niivue-canvas');

            const volumeList = {{ volume_list_js|safe }};
            const overlayColors = {{ overlay_colors_js|safe }};
            console.log('Prepared volumeList:', volumeList);
            console.log('Overlay colors:', overlayColors);
            if (!Array.isArray(volumeList) || volumeList.some(v => !v || typeof v.url !== 'string')) {
                console.error('Invalid volumeList shape. Expected [{ url: string }, ...]. Got:', volumeList);
            }

            {{ custom_colormap_js|safe }}
            if (typeof customSegmentationColormap !== 'undefined') {
                nv.addColormap('custom_segmentation', customSegmentationColormap);
                console.log('Custom segmentation colormap added with', customSegmentationColormap.R.length, 'entries');
                console.log('Sample colors from colormap:');
                console.log('  ID 1 (liver):', customSegmentationColormap.R[1], customSegmentationColormap.G[1], customSegmentationColormap.B[1]);
                console.log('  ID 3 (spleen):', customSegmentationColormap.R[3], customSegmentationColormap.G[3], customSegmentationColormap.B[3]);
                console.log('  ID 5 (right kidney):', customSegmentationColormap.R[5], customSegmentationColormap.G[5], customSegmentationColormap.B[5]);
                console.log('  ID 6 (aorta):', customSegmentationColormap.R[6], customSegmentationColormap.G[6], customSegmentationColormap.B[6]);
            } else {
                console.error('customSegmentationColormap was NOT defined!');
            }

            // Add the main volume colormap
            const mainColormapData = {{ color_map_data_js|safe }};
            const mainColormapName = {{ color_map_js|safe }};
            if (mainColormapData && !mainColormapData.__builtin__) {
                nv.addColormap(mainColormapName, mainColormapData);
                console.log('Added main volume colormap:', mainColormapName);
            } else if (mainColormapData && mainColormapData.__builtin__) {
                console.log('Using built-in colormap:', mainColormapName);
            }

            // For "all segmentation" mode, use the same colormap as individual voxels
            // This ensures consistent colors between individual voxels and all segmentation mode

            nv.loadVolumes(volumeList).then(() => {
                console.log('Volumes loaded successfully');
                console.log('Number of volumes loaded:', nv.volumes.length);
                
                // Fit view to show more of the CT scan after volumes are loaded
                setTimeout(() => {
                    if (nv.volumes && nv.volumes.length > 0) {
                        const mainVol = nv.volumes[0];
                        if (mainVol && mainVol.img && mainVol.dims && mainVol.mm) {
                            // Calculate volume dimensions and spacing
                            const dims = mainVol.dims;
                            const mm = mainVol.mm;
                            
                            // Check if dims and mm are valid arrays
                            if (!dims || dims.length < 3 || !mm || mm.length < 3) {
                                console.warn('Invalid dims or mm arrays for view fit calculation');
                                return;
                            }
                            
                            // Calculate the physical size of the volume
                            const physicalSize = [
                                dims[0] * mm[0],  // width in mm
                                dims[1] * mm[1],  // height in mm  
                                dims[2] * mm[2]   // depth in mm
                            ];
                            
                            // Find the largest dimension
                            const maxPhysicalSize = Math.max(...physicalSize);
                            
                            // Set camera distance to show more of the volume
                            if (nv.scene && nv.scene.cameras && nv.scene.cameras.length > 0) {
                                const camera = nv.scene.cameras[0];
                                if (camera) {
                                    // Set distance to fit the volume with configurable padding
                                    const zoomFactor = {{ view_fit_zoom|default(3.0) }};
                                    camera.distance = maxPhysicalSize * zoomFactor;
                                    console.log('Set camera distance to:', camera.distance, 'for volume size:', maxPhysicalSize, 'with zoom factor:', zoomFactor);
                                }
                            }
                            
                            // Reset clip planes to show the full volume
                            nv.clipPlane = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0];
                            
                            // Force a redraw
                            nv.drawScene();
                        }
                    }
                }, 200);
                nv.volumes.forEach((vol, idx) => {
                    console.log(`Volume ${idx}:`, {
                        id: vol.id,
                        url: vol.url,
                        name: vol.name || 'Unnamed',
                        cal_min: vol.cal_min,
                        cal_max: vol.cal_max,
                        colormap: vol.colormap
                    });
                });
                const hasVolumes = nv.volumes.length > 0;
                const mainVol = hasVolumes ? nv.volumes[0] : null;

                {% if main_is_nifti and main_vol %}
                if ({{ main_is_nifti|lower }} && mainVol) {
                    // MAIN VOLUME COLORMAP APPLICATION - DO NOT MODIFY WITHOUT CAREFUL TESTING
                    // Only apply grayscale colormap to actual NIFTI files, not voxel overlays
                    if (mainVol.url && !mainVol.url.includes('/voxels/')) {
                        nv.setColormap(mainVol.id, {{ color_map_js|safe }});
                        nv.setGamma({{ nifti_gamma }});
                        mainVol.opacity = {{ nifti_opacity }};

                        // Apply CT windowing settings
                        const windowCenter = {{ window_center }};
                        const windowWidth = {{ window_width }};
                        const windowMin = windowCenter - windowWidth / 2;
                        const windowMax = windowCenter + windowWidth / 2;

                        // Set the volume's display range for proper CT windowing
                        mainVol.cal_min = windowMin;
                        mainVol.cal_max = windowMax;

                        console.log('Applied CT windowing - Center:', windowCenter, 'Width:', windowWidth, 'Range:', windowMin, 'to', windowMax);
                    } else {
                        console.log('Skipping grayscale colormap for voxel file:', mainVol.url);
                        // Apply custom segmentation colormap to voxel files
                        if (typeof customSegmentationColormap !== 'undefined') {
                            nv.setColormap(mainVol.id, 'custom_segmentation');
                            console.log('Applied custom_segmentation colormap to main voxel volume');
                        }
                    }
                }
                {% endif %}

                // Apply individual colors to overlays
                if (nv.volumes.length > {{ overlay_start_index }}) {
                    for (let i = {{ overlay_start_index }}; i < nv.volumes.length; i++) {
                        const overlayVol = nv.volumes[i];
                        // Set opacity for voxel overlays - use higher opacity for better visibility
                        const isSingleView = {{ actual_slice_type }} !== 3 && {{ actual_slice_type }} !== 4;
                        // Use high opacity for single view, full opacity for 3D render to make voxels clearly visible
                        // Adjusted to work better with increased background visibility
                        overlayVol.opacity = isSingleView ? 0.8 : Math.max({{ segment_opacity }}, 0.8);
                        // Apply gamma to voxel overlays
                        nv.setGamma({{ segment_gamma }}, overlayVol.id);
                        
                        // Ensure voxels render on top with better visibility
                        overlayVol.renderOnTop = true;
                        overlayVol.alphaTest = 0.005; // Lower alpha test for better visibility
                        overlayVol.depthTest = false; // Render on top of other volumes

                        // Get the corresponding overlay color info
                        const overlayIndex = i - {{ overlay_start_index }};

                        // Check if this overlay should use the full custom segmentation colormap (all.nii.gz)
                        if (overlayIndex < overlayColors.length && overlayColors[overlayIndex].use_custom_colormap) {
                            // This is all.nii.gz - apply the full custom segmentation colormap
                            if (typeof customSegmentationColormap !== 'undefined') {
                                nv.setColormap(overlayVol.id, 'custom_segmentation');
                                overlayVol.cal_min = 0;
                                overlayVol.cal_max = customSegmentationColormap.maxLabelId || 255;
                                console.log('Applied custom_segmentation colormap to all.nii.gz');
                                console.log(`  Colormap range: 0 to ${overlayVol.cal_max}`);
                                console.log(`  Colormap entries: ${customSegmentationColormap.R.length}`);
                                
                                // Debug: Check actual voxel values in all.nii.gz
                                if (overlayVol.img && overlayVol.img.length > 0) {
                                    const data = overlayVol.img;
                                    const uniqueValues = new Set();
                                    for (let i = 0; i < Math.min(10000, data.length); i++) {
                                        if (data[i] !== 0) {
                                            uniqueValues.add(data[i]);
                                        }
                                    }
                                    const sortedValues = Array.from(uniqueValues).sort((a, b) => a - b);
                                    console.log(`  Unique label IDs in all.nii.gz:`, sortedValues);
                                    console.log(`  Total unique labels: ${sortedValues.length}`);
                                }
                            } else {
                                console.error('ERROR: customSegmentationColormap not defined for all.nii.gz!');
                            }
                        } else if (overlayIndex < overlayColors.length && overlayColors[overlayIndex].color) {
                            // Individual voxel file - create a colormap for the specific label
                            const color = overlayColors[overlayIndex].color;
                            const labelName = overlayColors[overlayIndex].label_name;
                            const labelId = overlayColors[overlayIndex].label_id;

                            // For individual voxel files, create a colormap that maps the label ID to the correct color
                            // Individual voxel files contain the label ID as the non-zero value
                            // We need to create a colormap that maps the specific label ID to the color
                            // Use minimal array size (labelId + 1) for efficiency and set cal_max to match
                            const maxId = labelId;
                            const rValues = new Array(maxId + 1).fill(0);
                            const gValues = new Array(maxId + 1).fill(0);
                            const bValues = new Array(maxId + 1).fill(0);
                            const aValues = new Array(maxId + 1).fill(0);
                            const labels = new Array(maxId + 1).fill('Background');
                            
                            // Set the specific label ID to the correct color
                            rValues[labelId] = color[0];
                            gValues[labelId] = color[1];
                            bValues[labelId] = color[2];
                            aValues[labelId] = 255;
                            labels[labelId] = labelName;
                            
                            const customColormap = {
                                R: rValues,
                                G: gValues,
                                B: bValues,
                                A: aValues,
                                labels: labels
                            };

                            const colormapName = `custom_${overlayIndex}`;
                            nv.addColormap(colormapName, customColormap);
                            nv.setColormap(overlayVol.id, colormapName);
                            
                            // Set the volume range to match the colormap size for direct indexing
                            overlayVol.cal_min = 0;
                            overlayVol.cal_max = maxId;
                            
                            console.log(`Applied custom color to overlay ${overlayIndex}: ${labelName} (ID: ${labelId})`, color);
                            console.log(`  Colormap has ${rValues.length} entries`);
                            console.log(`  Color at index ${labelId}: RGB(${rValues[labelId]}, ${gValues[labelId]}, ${bValues[labelId]}), A=${aValues[labelId]}`);
                            console.log(`  Overlay volume opacity: ${overlayVol.opacity}`);
                            console.log(`  Overlay volume renderOnTop: ${overlayVol.renderOnTop}`);
                            console.log(`Set volume range: ${overlayVol.cal_min} to ${overlayVol.cal_max}`);
                            
                            // Debug: Check actual voxel values
                            if (overlayVol.img && overlayVol.img.length > 0) {
                                const data = overlayVol.img;
                                const uniqueValues = new Set();
                                for (let i = 0; i < Math.min(10000, data.length); i++) {
                                    if (data[i] !== 0) {
                                        uniqueValues.add(data[i]);
                                    }
                                }
                                console.log(`  Unique values in individual voxel file:`, Array.from(uniqueValues).sort((a, b) => a - b));
                            }
                        } else {
                            // Fallback for overlays without proper color info
                            console.warn('WARNING: Overlay without proper color information:', overlayVol.url);
                            console.warn('  This indicates a potential issue with overlay creation');
                            
                            // Fallback: try to apply generic segmentation colormap
                            if (typeof customSegmentationColormap !== 'undefined') {
                                nv.setColormap(overlayVol.id, 'custom_segmentation');
                                overlayVol.cal_min = 0;
                                overlayVol.cal_max = customSegmentationColormap.maxLabelId || 255;
                                console.log('  Applied fallback custom_segmentation colormap');
                            }
                        }
                    }
                }

                // PROTECTED: Re-enforce main volume colormap after overlay processing to prevent interference
                {% if main_is_nifti and main_vol %}
                if ({{ main_is_nifti|lower }} && mainVol) {
                    nv.setColormap(mainVol.id, {{ color_map_js|safe }});
                    console.log('Re-applied main volume colormap after overlay processing');
                }
                {% endif %}

                // Enforce requested slice type pre- and post-opts to avoid regressions
                const requestedSliceType = {{ actual_slice_type }};
                nv.setSliceType(requestedSliceType);
                console.log('Applied slice type index:', {{ actual_slice_type }});
                {% if actual_slice_type == 3 %}
                // Multiplanar view with 4 panes
                nv.opts.multiplanarShowRender = true;
                nv.opts.multiplanarForceRender = true;
                nv.opts.showCrosshairs = true;
                nv.opts.show3Dcrosshair = true;
                // Enable 3D rendering for the bottom-right panel
                nv.opts.isOrientCube = false;
                nv.opts.isRuler = false;
                setTimeout(() => {
                    nv.drawScene();
                }, 500);
                {% elif actual_slice_type == 4 %}
                // 3D Render mode - full 3D view with enhanced quality
                nv.opts.multiplanarShowRender = false;
                nv.opts.multiplanarForceRender = false;
                nv.opts.showCrosshairs = false;
                nv.opts.show3Dcrosshair = true;
                nv.opts.isOrientCube = false;
                nv.opts.isRuler = false;
                nv.opts.isRadiologicalConvention = false;
                
                // Enhanced 3D rendering quality settings - loaded from config
                const renderConfig = {{ render_config_js|safe }};
                Object.keys(renderConfig).forEach(key => {
                    nv.opts[key] = renderConfig[key];
                });
                
                // Enable 3D rendering
                setTimeout(() => {
                    nv.drawScene();
                }, 500);
                {% else %}
                // Ensure multiplanar flags are disabled when not in multiplanar mode
                nv.opts.multiplanarShowRender = false;
                nv.opts.multiplanarForceRender = false;
                nv.opts.showCrosshairs = true;
                nv.opts.show3Dcrosshair = false;
                // Defensive re-apply in case prior state forced multiplanar
                nv.setSliceType({{ actual_slice_type }});
                {% endif %}
                // Final enforcement after opts toggles
                nv.setSliceType(requestedSliceType);
                
                // Fit view to show more of the CT scan
                setTimeout(() => {
                    if (nv.volumes && nv.volumes.length > 0) {
                        // Get the main volume bounds and fit the view
                        const mainVol = nv.volumes[0];
                        if (mainVol && mainVol.img && mainVol.dims && mainVol.mm) {
                            // Calculate the bounding box of the volume
                            const dims = mainVol.dims;
                            const mm = mainVol.mm;
                            
                            // Check if dims and mm are valid arrays
                            if (dims && dims.length >= 3 && mm && mm.length >= 3) {
                                // Set clip planes to show more of the volume
                                nv.clipPlane = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0];
                                
                                // Adjust zoom to fit more of the volume
                                if (nv.scene && nv.scene.cameras) {
                                    const camera = nv.scene.cameras[0];
                                    if (camera) {
                                        // Calculate distance to fit the volume
                                        const maxDim = Math.max(dims[0] * mm[0], dims[1] * mm[1], dims[2] * mm[2]);
                                        const zoomFactor = {{ view_fit_zoom|default(3.0) }};
                                        camera.distance = maxDim * zoomFactor; // Show more of the volume
                                    }
                                }
                            }
                        }
                    }
                }, 100);
                
                nv.drawScene();

                // Final redraw to ensure colormap is applied
                setTimeout(() => {
                    nv.drawScene();
                }, 100);

                // Lightweight guard: re-apply requested slice type after short delays
                // This protects against any late state changes from future edits
                [0, 250, 1000].forEach((ms) => {
                    setTimeout(() => {
                        if (nv.getSliceType && typeof nv.getSliceType === 'function') {
                            const current = nv.getSliceType();
                            if (current !== requestedSliceType) {
                                nv.setSliceType(requestedSliceType);
                                nv.drawScene();
                            }
                        } else {
                            // Fallback if API is unavailable
                            nv.setSliceType(requestedSliceType);
                            nv.drawScene();
                        }
                    }, ms);
                });

                // Removed label readout handler per request

            }).catch((error) => {
                console.error('Error loading volumes:', error);
                console.error('Volume list that failed:', volumeList);
                console.error('Error details:', {
                    message: error.message,
                    stack: error.stack,
                    name: error.name
                });

                // Try to provide more helpful error information
                if (error.message && error.message.includes('fetch')) {
                    console.error('Network error - check if image server is running and file exists');
                } else if (error.message && error.message.includes('parse')) {
                    console.error('File parsing error - check if file is valid NIfTI format');
                } else {
                    console.error('Unknown error during volume loading');
                }
            });
        }
    </script>
</body>
</html>
