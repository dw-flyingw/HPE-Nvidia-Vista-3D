<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <style>
        body, html { margin: 0; padding: 0; width: 100%; height: 100%; overflow: hidden; }
        #niivue-canvas { width: 100%; height: 100%; display: block; pointer-events: auto; }
    </style>
</head>
<body>
    <canvas id="niivue-canvas"></canvas>
    <script>{{ niivue_lib_content|safe }}</script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pako/2.1.0/pako.min.js"></script>
    <script src="/utils/colormap_manager.js"></script>
    <script>
        if (typeof niivue === 'undefined') {
            console.error('Niivue library not loaded!');
        } else {
            console.log('NiiVue library loaded successfully');

            const nv = new niivue.Niivue({
                isColorbar: false,
                loadingText: 'loading ...',
                dragAndDropEnabled: false,
                isResizeCanvas: true,
                crosshairWidth: 1,
                crosshairColor: [1, 0, 0, 1],
                backColor: [0, 0, 0, 1]
            });
            nv.attachTo('niivue-canvas');

            const volumeList = {{ volume_list_js|safe }};
            const overlayColors = {{ overlay_colors_js|safe }};
            console.log('Prepared volumeList:', volumeList);
            console.log('Overlay colors:', overlayColors);
            if (!Array.isArray(volumeList) || volumeList.some(v => !v || typeof v.url !== 'string')) {
                console.error('Invalid volumeList shape. Expected [{ url: string }, ...]. Got:', volumeList);
            }

            {{ custom_colormap_js|safe }}
            if (typeof customSegmentationColormap !== 'undefined') {
                nv.addColormap('custom_segmentation', customSegmentationColormap);
                console.log('Custom segmentation colormap added');
            }

            // For "all segmentation" mode, use the same colormap as individual voxels
            // This ensures consistent colors between individual voxels and all segmentation mode

            nv.loadVolumes(volumeList).then(() => {
                console.log('Volumes loaded successfully');
                const hasVolumes = nv.volumes.length > 0;
                const mainVol = hasVolumes ? nv.volumes[0] : null;

                {% if main_is_nifti and main_vol %}
                if ({{ main_is_nifti|lower }} && mainVol) {
                    // MAIN VOLUME COLORMAP APPLICATION - DO NOT MODIFY WITHOUT CAREFUL TESTING
                    nv.setColormap(mainVol.id, {{ color_map_js|safe }});
                    nv.setGamma({{ nifti_gamma }});
                    mainVol.opacity = {{ nifti_opacity }};

                    // Apply CT windowing settings
                    const windowCenter = {{ window_center }};
                    const windowWidth = {{ window_width }};
                    const windowMin = windowCenter - windowWidth / 2;
                    const windowMax = windowCenter + windowWidth / 2;

                    // Set the volume's display range for proper CT windowing
                    mainVol.cal_min = windowMin;
                    mainVol.cal_max = windowMax;

                    console.log('Applied CT windowing - Center:', windowCenter, 'Width:', windowWidth, 'Range:', windowMin, 'to', windowMax);
                }
                {% endif %}

                // Apply individual colors to overlays
                if (nv.volumes.length > {{ overlay_start_index }}) {
                    for (let i = {{ overlay_start_index }}; i < nv.volumes.length; i++) {
                        const overlayVol = nv.volumes[i];
                        // Set opacity to 50% for Single View mode, otherwise use slider value
                        const isSingleView = {{ actual_slice_type }} !== 3 && {{ actual_slice_type }} !== 4;
                        overlayVol.opacity = isSingleView ? 0.5 : {{ segment_opacity }};

                        // Get the corresponding overlay color info
                        const overlayIndex = i - {{ overlay_start_index }};

                        // Check if this is the "all segmentation" mode
                        if (overlayIndex < overlayColors.length && overlayColors[overlayIndex].is_all_segmentation) {
                            // Use the same colormap as individual voxels for consistency
                            if (typeof customSegmentationColormap !== 'undefined') {
                                nv.setColormap(overlayVol.id, 'custom_segmentation');
                                console.log('Applied custom_segmentation colormap to all segmentation overlay');
                            }
                        } else if (overlayIndex < overlayColors.length && overlayColors[overlayIndex].color) {
                            const color = overlayColors[overlayIndex].color;
                            const labelName = overlayColors[overlayIndex].label_name;

                            // Create a custom colormap for this specific overlay
                            const customColormap = {
                                R: [0, color[0]],
                                G: [0, color[1]],
                                B: [0, color[2]],
                                A: [0, 255],
                                labels: ['Background', labelName]
                            };

                            const colormapName = `custom_${overlayIndex}`;
                            nv.addColormap(colormapName, customColormap);
                            nv.setColormap(overlayVol.id, colormapName);
                            console.log(`Applied custom color to overlay ${overlayIndex}: ${labelName}`, color);
                        } else {
                            // Fallback to generic segmentation colormap
                            if (typeof customSegmentationColormap !== 'undefined') {
                                nv.setColormap(overlayVol.id, 'custom_segmentation');
                                console.log('Applied custom_segmentation colormap to overlay volume:', overlayVol.id, 'Name:', overlayVol.name || 'Unnamed');
                            }
                        }
                    }
                }

                // PROTECTED: Re-enforce main volume colormap after overlay processing to prevent interference
                {% if main_is_nifti and main_vol %}
                if ({{ main_is_nifti|lower }} && mainVol) {
                    nv.setColormap(mainVol.id, {{ color_map_js|safe }});
                    console.log('Re-applied main volume colormap after overlay processing');
                }
                {% endif %}

                // Honor requested slice type
                nv.setSliceType({{ actual_slice_type }});
                {% if actual_slice_type == 3 %}
                // Multiplanar view with 4 panes
                nv.opts.multiplanarShowRender = true;
                nv.opts.multiplanarForceRender = true;
                nv.opts.showCrosshairs = true;
                nv.opts.show3Dcrosshair = true;
                // Enable 3D rendering for the bottom-right panel
                nv.opts.isOrientCube = false;
                nv.opts.isRuler = false;
                setTimeout(() => {
                    nv.drawScene();
                }, 500);
                {% elif actual_slice_type == 4 %}
                // 3D Render mode - full 3D view
                nv.opts.multiplanarShowRender = false;
                nv.opts.multiplanarForceRender = false;
                nv.opts.showCrosshairs = false;
                nv.opts.show3Dcrosshair = true;
                nv.opts.isOrientCube = false;
                nv.opts.isRuler = false;
                nv.opts.isRadiologicalConvention = false;
                // Enable 3D rendering
                setTimeout(() => {
                    nv.drawScene();
                }, 500);
                {% else %}
                // Ensure multiplanar flags are disabled when not in multiplanar mode
                nv.opts.multiplanarShowRender = false;
                nv.opts.multiplanarForceRender = false;
                nv.opts.showCrosshairs = false;
                nv.opts.show3Dcrosshair = false;
                {% endif %}
                nv.drawScene();

                // Final redraw to ensure colormap is applied
                setTimeout(() => {
                    nv.drawScene();
                }, 100);

            }).catch((error) => {
                console.error('Error loading volumes:', error);
                console.error('Volume list that failed:', volumeList);
                console.error('Error details:', {
                    message: error.message,
                    stack: error.stack,
                    name: error.name
                });

                // Try to provide more helpful error information
                if (error.message && error.message.includes('fetch')) {
                    console.error('Network error - check if image server is running and file exists');
                } else if (error.message && error.message.includes('parse')) {
                    console.error('File parsing error - check if file is valid NIfTI format');
                } else {
                    console.error('Unknown error during volume loading');
                }
            });
        }
    </script>
</body>
</html>
