<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <style>
        body, html { margin: 0; padding: 0; width: 100%; height: 100%; overflow: hidden; }
        #niivue-canvas { width: 100%; height: 100%; display: block; pointer-events: auto; }
    </style>
</head>
<body>
    <canvas id="niivue-canvas"></canvas>
    <script>{{ niivue_lib_content|safe }}</script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pako/2.1.0/pako.min.js"></script>
    <script src="/utils/colormap_manager.js"></script>
    <script>
        if (typeof niivue === 'undefined') {
            console.error('Niivue library not loaded!');
        } else {
            console.log('NiiVue library loaded successfully');

            const nv = new niivue.Niivue({
                isColorbar: false,
                loadingText: 'loading ...',
                dragAndDropEnabled: false,
                isResizeCanvas: true,
                crosshairWidth: 1,
                crosshairColor: [1, 0, 0, 1],
                backColor: [0, 0, 0, 1]
            });
            nv.attachTo('niivue-canvas');

            const volumeList = {{ volume_list_js|safe }};
            const overlayColors = {{ overlay_colors_js|safe }};
            console.log('Prepared volumeList:', volumeList);
            console.log('Overlay colors:', overlayColors);
            if (!Array.isArray(volumeList) || volumeList.some(v => !v || typeof v.url !== 'string')) {
                console.error('Invalid volumeList shape. Expected [{ url: string }, ...]. Got:', volumeList);
            }

            {{ custom_colormap_js|safe }}
            if (typeof customSegmentationColormap !== 'undefined') {
                // Create a normalized colormap for NiiVue (values 0-1)
                const normalizedColormap = {
                    R: customSegmentationColormap.R.map(v => v / 255),
                    G: customSegmentationColormap.G.map(v => v / 255),
                    B: customSegmentationColormap.B.map(v => v / 255),
                    A: customSegmentationColormap.A.map(v => v / 255),
                    labels: customSegmentationColormap.labels
                };
                
                nv.addColormap('custom_segmentation', normalizedColormap);
                console.log('Custom segmentation colormap added (normalized):', normalizedColormap);
                console.log('First 10 normalized colors:', {
                    R: normalizedColormap.R.slice(0, 10),
                    G: normalizedColormap.G.slice(0, 10),
                    B: normalizedColormap.B.slice(0, 10)
                });
                
                // Also add the original format as backup
                nv.addColormap('vista3d_original', customSegmentationColormap);
                console.log('Original format colormap added as backup');
            } else {
                console.error('Custom segmentation colormap is undefined!');
            }

            // For "all segmentation" mode, use the same colormap as individual voxels
            // This ensures consistent colors between individual voxels and all segmentation mode

            nv.loadVolumes(volumeList).then(() => {
                console.log('Volumes loaded successfully');
                const hasVolumes = nv.volumes.length > 0;
                const mainVol = hasVolumes ? nv.volumes[0] : null;

                {% if main_is_nifti and main_vol %}
                if ({{ main_is_nifti|lower }} && mainVol) {
                    // MAIN VOLUME COLORMAP APPLICATION - DO NOT MODIFY WITHOUT CAREFUL TESTING
                    nv.setColormap(mainVol.id, {{ color_map_js|safe }});
                    nv.setGamma({{ nifti_gamma }});
                    mainVol.opacity = {{ nifti_opacity }};

                    // Apply CT windowing settings
                    const windowCenter = {{ window_center }};
                    const windowWidth = {{ window_width }};
                    const windowMin = windowCenter - windowWidth / 2;
                    const windowMax = windowCenter + windowWidth / 2;

                    // Set the volume's display range for proper CT windowing
                    mainVol.cal_min = windowMin;
                    mainVol.cal_max = windowMax;

                    console.log('Applied CT windowing - Center:', windowCenter, 'Width:', windowWidth, 'Range:', windowMin, 'to', windowMax);
                }
                {% endif %}

                // Apply individual colors to overlays
                if (nv.volumes.length > {{ overlay_start_index }}) {
                    for (let i = {{ overlay_start_index }}; i < nv.volumes.length; i++) {
                        const overlayVol = nv.volumes[i];
                        // Set opacity to 50% for Single View mode, otherwise use slider value
                        const isSingleView = {{ actual_slice_type }} !== 3 && {{ actual_slice_type }} !== 4;
                        overlayVol.opacity = isSingleView ? 0.5 : {{ segment_opacity }};

                        // Get the corresponding overlay color info
                        const overlayIndex = i - {{ overlay_start_index }};

                        // Check if this is the "all segmentation" mode
                        if (overlayIndex < overlayColors.length && overlayColors[overlayIndex].is_all_segmentation) {
                            console.log('=== ALL SEGMENTATION OVERLAY DETECTED ===');
                            console.log('Overlay ID:', overlayVol.id);
                            console.log('Overlay URL:', overlayColors[overlayIndex].url);
                            
                            // Apply Vista3D colormap
                            nv.setColormap(overlayVol.id, 'vista3d_original');
                            
                            // Set and log properties
                            overlayVol.opacity = {{ segment_opacity }};
                            console.log('Set opacity to:', overlayVol.opacity);
                            console.log('Volume visible after setup:', overlayVol.visible);
                            
                            // Add a check to monitor if the overlay disappears
                            setTimeout(() => {
                                console.log('=== 2 SECOND CHECK ===');
                                console.log('Overlay still visible?:', overlayVol.visible);
                                console.log('Overlay opacity now:', overlayVol.opacity);
                                console.log('Current colormap:', overlayVol.colormap);
                            }, 2000);
                        } else if (overlayIndex < overlayColors.length && overlayColors[overlayIndex].color) {
                            const color = overlayColors[overlayIndex].color;
                            const labelName = overlayColors[overlayIndex].label_name;

                            // Create a custom colormap for this specific overlay
                            const customColormap = {
                                R: [0, color[0]],
                                G: [0, color[1]],
                                B: [0, color[2]],
                                A: [0, 255],
                                labels: ['Background', labelName]
                            };

                            const colormapName = `custom_${overlayIndex}`;
                            nv.addColormap(colormapName, customColormap);
                            nv.setColormap(overlayVol.id, colormapName);
                            console.log(`Applied custom color to overlay ${overlayIndex}: ${labelName}`, color);
                        } else {
                            // Fallback to generic segmentation colormap
                            if (typeof customSegmentationColormap !== 'undefined') {
                                nv.setColormap(overlayVol.id, 'custom_segmentation');
                                console.log('Applied custom_segmentation colormap to overlay volume (fallback):', overlayVol.id, 'Name:', overlayVol.name || 'Unnamed');
                                // Force a redraw to ensure the colormap is applied
                                setTimeout(() => {
                                    nv.drawScene();
                                }, 100);
                            } else {
                                console.error('Custom segmentation colormap is undefined in fallback!');
                            }
                        }
                    }
                }

                // PROTECTED: Re-enforce main volume colormap after overlay processing to prevent interference
                {% if main_is_nifti and main_vol %}
                if ({{ main_is_nifti|lower }} && mainVol) {
                    // Only apply to the main volume, not overlays
                    if (mainVol.id !== nv.volumes[{{ overlay_start_index }}]?.id) {
                        nv.setColormap(mainVol.id, {{ color_map_js|safe }});
                        console.log('Re-applied main volume colormap after overlay processing');
                    }
                }
                {% endif %}

                // Honor requested slice type
                const sliceType = {{ actual_slice_type }};
                console.log('Setting slice type to:', sliceType);
                nv.setSliceType(sliceType);
                
                // Configure view options based on slice type
                if (sliceType === 3) {
                    // Multiplanar view with 4 panes
                    console.log('Configuring for Multiplanar view');
                    nv.opts.multiplanarShowRender = true;
                    nv.opts.multiplanarForceRender = true;
                    nv.opts.showCrosshairs = true;
                    nv.opts.show3Dcrosshair = true;
                    nv.opts.isOrientCube = false;
                    nv.opts.isRuler = false;
                } else if (sliceType === 4) {
                    // 3D Render mode - full 3D view
                    console.log('Configuring for 3D Render view');
                    nv.opts.multiplanarShowRender = false;
                    nv.opts.multiplanarForceRender = false;
                    nv.opts.showCrosshairs = false;
                    nv.opts.show3Dcrosshair = true;
                    nv.opts.isOrientCube = false;
                    nv.opts.isRuler = false;
                    nv.opts.isRadiologicalConvention = false;
                } else {
                    // Single view modes (0, 1, 2)
                    console.log('Configuring for Single view mode');
                    nv.opts.multiplanarShowRender = false;
                    nv.opts.multiplanarForceRender = false;
                    nv.opts.showCrosshairs = false;
                    nv.opts.show3Dcrosshair = false;
                }
                
                nv.drawScene();
                
                // Simple final step: just ensure 3D render mode if needed
                setTimeout(() => {
                    // Force 3D render mode if slice type is 4
                    if (sliceType === 4) {
                        console.log('Final: Ensuring 3D render mode');
                        nv.setSliceType(4);
                        nv.opts.multiplanarShowRender = false;
                        nv.opts.multiplanarForceRender = false;
                        nv.opts.showCrosshairs = false;
                        nv.opts.show3Dcrosshair = true;
                        nv.drawScene();
                    }
                }, 500);

                

            }).catch((error) => {
                console.error('Error loading volumes:', error);
                console.error('Volume list that failed:', volumeList);
                console.error('Error details:', {
                    message: error.message,
                    stack: error.stack,
                    name: error.name
                });

                // Try to provide more helpful error information
                if (error.message && error.message.includes('fetch')) {
                    console.error('Network error - check if image server is running and file exists');
                } else if (error.message && error.message.includes('parse')) {
                    console.error('File parsing error - check if file is valid NIfTI format');
                } else {
                    console.error('Unknown error during volume loading');
                }
            });
        }
    </script>
</body>
</html>
