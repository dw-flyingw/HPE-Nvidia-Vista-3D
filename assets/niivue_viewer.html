<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <style>
        body, html { margin: 0; padding: 0; width: 100%; height: 100%; overflow: hidden; }
        #niivue-canvas { width: 100%; height: 100%; display: block; pointer-events: auto; }
    </style>
</head>
<body>
    <canvas id="niivue-canvas"></canvas>
    
    <!-- Hidden elements to store JSON data safely -->
    <div id="volume-list-data" style="display: none;">{{ volume_list_js|safe }}</div>
    <div id="overlay-colors-data" style="display: none;">{{ overlay_colors_js|safe }}</div>
    
    <!-- Hidden elements for template variables -->
    <div id="main-is-nifti" style="display: none;">{{ main_is_nifti }}</div>
    <div id="color-map-js" style="display: none;">{{ color_map_js|safe }}</div>
    <div id="nifti-gamma" style="display: none;">{{ nifti_gamma }}</div>
    <div id="nifti-opacity" style="display: none;">{{ nifti_opacity }}</div>
    <div id="window-center" style="display: none;">{{ window_center }}</div>
    <div id="window-width" style="display: none;">{{ window_width }}</div>
    <div id="overlay-start-index" style="display: none;">{{ overlay_start_index }}</div>
    <div id="actual-slice-type" style="display: none;">{{ actual_slice_type }}</div>
    <div id="segment-opacity" style="display: none;">{{ segment_opacity }}</div>
    <script>
        {{ niivue_lib_content|safe }}
    </script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pako/2.1.0/pako.min.js"></script>
    <script>
        // Set the image server URL for the colormap manager
        window.IMAGE_SERVER_URL = '{{ image_server_url }}';
        console.log('Image server URL set to:', window.IMAGE_SERVER_URL);
    </script>
    <script>
        {{ colormap_manager_content|safe }}
    </script>
    <script>
        if (typeof niivue === 'undefined') {
            console.error('Niivue library not loaded!');
        } else {
            console.log('NiiVue library loaded successfully');

            const nv = new niivue.Niivue({
                isColorbar: false,
                loadingText: 'loading ...',
                dragAndDropEnabled: false,
                isResizeCanvas: true,
                crosshairWidth: 1,
                crosshairColor: [1, 0, 0, 1],
                backColor: [0, 0, 0, 1]
            });
            nv.attachTo('niivue-canvas');

            // Safely load template variables using hidden elements
            let volumeList = [];
            let overlayColors = [];
            try {
                const volumeListElement = document.getElementById('volume-list-data');
                const overlayColorsElement = document.getElementById('overlay-colors-data');
                if (volumeListElement && volumeListElement.textContent) {
                    volumeList = JSON.parse(volumeListElement.textContent);
                }
                if (overlayColorsElement && overlayColorsElement.textContent) {
                    overlayColors = JSON.parse(overlayColorsElement.textContent);
                }
            } catch (e) {
                console.error('Error parsing template data:', e);
            }
            
            // Safely load other template variables
            let mainIsNifti = true;
            let colorMapJs = 'gray';
            let niftiGamma = 1.0;
            let niftiOpacity = 1.0;
            let windowCenter = 0;
            let windowWidth = 1000;
            let overlayStartIndex = 1;
            let actualSliceType = 3;
            let segmentOpacity = 0.5;
            
            try {
                const mainIsNiftiElement = document.getElementById('main-is-nifti');
                const colorMapJsElement = document.getElementById('color-map-js');
                const niftiGammaElement = document.getElementById('nifti-gamma');
                const niftiOpacityElement = document.getElementById('nifti-opacity');
                const windowCenterElement = document.getElementById('window-center');
                const windowWidthElement = document.getElementById('window-width');
                const overlayStartIndexElement = document.getElementById('overlay-start-index');
                const actualSliceTypeElement = document.getElementById('actual-slice-type');
                const segmentOpacityElement = document.getElementById('segment-opacity');
                
                if (mainIsNiftiElement && mainIsNiftiElement.textContent) {
                    mainIsNifti = mainIsNiftiElement.textContent.toLowerCase() === 'true';
                }
                if (colorMapJsElement && colorMapJsElement.textContent) {
                    colorMapJs = colorMapJsElement.textContent;
                }
                if (niftiGammaElement && niftiGammaElement.textContent) {
                    niftiGamma = parseFloat(niftiGammaElement.textContent) || 1.0;
                }
                if (niftiOpacityElement && niftiOpacityElement.textContent) {
                    niftiOpacity = parseFloat(niftiOpacityElement.textContent) || 1.0;
                }
                if (windowCenterElement && windowCenterElement.textContent) {
                    windowCenter = parseFloat(windowCenterElement.textContent) || 0;
                }
                if (windowWidthElement && windowWidthElement.textContent) {
                    windowWidth = parseFloat(windowWidthElement.textContent) || 1000;
                }
                if (overlayStartIndexElement && overlayStartIndexElement.textContent) {
                    overlayStartIndex = parseInt(overlayStartIndexElement.textContent) || 1;
                }
                if (actualSliceTypeElement && actualSliceTypeElement.textContent) {
                    actualSliceType = parseInt(actualSliceTypeElement.textContent) || 3;
                }
                if (segmentOpacityElement && segmentOpacityElement.textContent) {
                    segmentOpacity = parseFloat(segmentOpacityElement.textContent) || 0.5;
                }
            } catch (e) {
                console.error('Error parsing template variables:', e);
            }
            
            console.log('Prepared volumeList:', volumeList);
            console.log('Overlay colors:', overlayColors);
            if (!Array.isArray(volumeList) || volumeList.some(v => !v || typeof v.url !== 'string')) {
                console.error('Invalid volumeList shape. Expected [{ url: string }, ...]. Got:', volumeList);
            }

            // Load Vista3D voxels colormap from the colormap system
            let customSegmentationColormap = null;
            
            // Check if ColormapManager is available and load the voxels colormap
            if (typeof window.ColormapManager !== 'undefined') {
                const colormapManager = new window.ColormapManager();
                // Wait for colormaps to load, then get the Vista3D anatomical colormap
                setTimeout(() => {
                    try {
                        const voxelsSet = colormapManager.getSetInfo('vista3d_voxels');
                        if (voxelsSet && voxelsSet.colormaps && voxelsSet.colormaps.vista3d_anatomical) {
                            customSegmentationColormap = voxelsSet.colormaps.vista3d_anatomical;
                            console.log('Vista3D voxels colormap loaded from colormap system:', customSegmentationColormap);
                        } else {
                            console.warn('Vista3D voxels colormap not found in colormap system');
                        }
                    } catch (error) {
                        console.error('Error loading Vista3D voxels colormap from colormap system:', error);
                    }
                }, 100);
            } else {
                console.warn('ColormapManager not available, falling back to fetch');
                // Fallback: direct fetch of the colormap file
                const imageServerUrl = window.IMAGE_SERVER_URL || '{{ image_server_url }}';
                fetch(`${imageServerUrl}/assets/colormaps/vista3d_voxels.json`)
                    .then(response => {
                        if (!response.ok) {
                            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                        }
                        return response.json();
                    })
                    .then(data => {
                        if (data && data.colormaps && data.colormaps.vista3d_anatomical) {
                            customSegmentationColormap = data.colormaps.vista3d_anatomical;
                            console.log('Vista3D voxels colormap loaded via direct fetch:', customSegmentationColormap);
                        } else {
                            console.warn('Vista3D voxels colormap data structure invalid:', data);
                        }
                    })
                    .catch(error => {
                        console.error('Error loading Vista3D voxels colormap:', error);
                    });
            }
            
            // Function to safely access colormap properties
            function safeGetColormapProperty(colormap, property) {
                if (!colormap || typeof colormap !== 'object') {
                    console.warn('Invalid colormap object:', colormap);
                    return null;
                }
                
                if (!colormap[property] || !Array.isArray(colormap[property])) {
                    console.warn(`Invalid or missing ${property} property in colormap:`, colormap[property]);
                    return null;
                }
                
                return colormap[property];
            }
            
            // Function to create normalized colormap
            function createNormalizedColormap(colormap) {
                if (!colormap) {
                    console.error('Cannot create normalized colormap: colormap is null/undefined');
                    return null;
                }
                
                const R = safeGetColormapProperty(colormap, 'R');
                const G = safeGetColormapProperty(colormap, 'G');
                const B = safeGetColormapProperty(colormap, 'B');
                const A = safeGetColormapProperty(colormap, 'A');
                const labels = safeGetColormapProperty(colormap, 'labels');
                
                if (!R || !G || !B || !A || !labels) {
                    console.error('Cannot create normalized colormap: missing required properties');
                    return null;
                }
                
                return {
                    R: R.map(v => v / 255),
                    G: G.map(v => v / 255),
                    B: B.map(v => v / 255),
                    A: A.map(v => v / 255),
                    labels: labels
                };
            }
            
            // Wait for colormap to load before proceeding
            function waitForColormapAndProceed() {
                if (customSegmentationColormap) {
                    proceedWithColormap();
                } else {
                    // Wait a bit more and try again
                    setTimeout(waitForColormapAndProceed, 100);
                }
            }
            
            function proceedWithColormap() {
                if (customSegmentationColormap) {
                    // Create a normalized colormap for NiiVue (values 0-1)
                    const normalizedColormap = createNormalizedColormap(customSegmentationColormap);
                    
                    if (normalizedColormap) {
                        nv.addColormap('custom_segmentation', normalizedColormap);
                        console.log('Custom segmentation colormap added (normalized):', normalizedColormap);
                        console.log('First 10 normalized colors:', {
                            R: normalizedColormap.R.slice(0, 10),
                            G: normalizedColormap.G.slice(0, 10),
                            B: normalizedColormap.B.slice(0, 10)
                        });
                        
                        // Also add the original format as backup
                        nv.addColormap('vista3d_original', customSegmentationColormap);
                        console.log('Original format colormap added as backup');
                    } else {
                        console.error('Failed to create normalized colormap');
                    }
                } else {
                    console.error('Custom segmentation colormap is undefined!');
                }
                
                // Proceed with volume loading
                loadVolumes();
            }

            function loadVolumes() {
                nv.loadVolumes(volumeList).then(() => {
                console.log('Volumes loaded successfully');
                const hasVolumes = nv.volumes.length > 0;
                const mainVol = hasVolumes ? nv.volumes[0] : null;

                if (mainIsNifti && mainVol) {
                    // MAIN VOLUME COLORMAP APPLICATION - DO NOT MODIFY WITHOUT CAREFUL TESTING
                    nv.setColormap(mainVol.id, colorMapJs);
                    nv.setGamma(niftiGamma);
                    mainVol.opacity = niftiOpacity;

                    // Apply CT windowing settings
                    const windowCenterValue = windowCenter;
                    const windowWidthValue = windowWidth;
                    const windowMin = windowCenterValue - windowWidthValue / 2;
                    const windowMax = windowCenterValue + windowWidthValue / 2;

                    // Set the volume's display range for proper CT windowing
                    mainVol.cal_min = windowMin;
                    mainVol.cal_max = windowMax;

                    console.log('Applied CT windowing - Center:', windowCenter, 'Width:', windowWidth, 'Range:', windowMin, 'to', windowMax);
                }

                // Apply individual colors to overlays
                if (nv.volumes.length > overlayStartIndex) {
                    for (let i = overlayStartIndex; i < nv.volumes.length; i++) {
                        const overlayVol = nv.volumes[i];
                        // Set opacity to 50% for Single View mode, otherwise use slider value
                        const isSingleView = actualSliceType !== 3 && actualSliceType !== 4;
                        overlayVol.opacity = isSingleView ? 0.5 : segmentOpacity;

                        // Get the corresponding overlay color info
                        const overlayIndex = i - overlayStartIndex;

                        // Check if this is the "all segmentation" mode
                        if (overlayIndex < overlayColors.length && overlayColors[overlayIndex].is_all_segmentation) {
                            console.log('=== ALL SEGMENTATION OVERLAY DETECTED ===');
                            console.log('Overlay ID:', overlayVol.id);
                            console.log('Overlay URL:', overlayColors[overlayIndex].url);
                            
                            // Apply Vista3D colormap
                            nv.setColormap(overlayVol.id, 'vista3d_original');
                            
                            // Set and log properties
                            overlayVol.opacity = segmentOpacity;
                            console.log('Set opacity to:', overlayVol.opacity);
                            console.log('Volume visible after setup:', overlayVol.visible);
                            
                            // Add a check to monitor if the overlay disappears
                            setTimeout(() => {
                                console.log('=== 2 SECOND CHECK ===');
                                console.log('Overlay still visible?:', overlayVol.visible);
                                console.log('Overlay opacity now:', overlayVol.opacity);
                                console.log('Current colormap:', overlayVol.colormap);
                            }, 2000);
                        } else if (overlayIndex < overlayColors.length && overlayColors[overlayIndex].color) {
                            const color = overlayColors[overlayIndex].color;
                            const labelName = overlayColors[overlayIndex].label_name;

                            // Create a custom colormap for this specific overlay
                            const customColormap = {
                                R: [0, color[0]],
                                G: [0, color[1]],
                                B: [0, color[2]],
                                A: [0, 255],
                                labels: ['Background', labelName]
                            };

                            const colormapName = `custom_${overlayIndex}`;
                            nv.addColormap(colormapName, customColormap);
                            nv.setColormap(overlayVol.id, colormapName);
                            console.log(`Applied custom color to overlay ${overlayIndex}: ${labelName}`, color);
                        } else {
                            // Fallback to generic segmentation colormap
                            if (typeof customSegmentationColormap !== 'undefined') {
                                nv.setColormap(overlayVol.id, 'custom_segmentation');
                                console.log('Applied custom_segmentation colormap to overlay volume (fallback):', overlayVol.id, 'Name:', overlayVol.name || 'Unnamed');
                                // Force a redraw to ensure the colormap is applied
                                setTimeout(() => {
                                    nv.drawScene();
                                }, 100);
                            } else {
                                console.error('Custom segmentation colormap is undefined in fallback!');
                            }
                        }
                    }
                }

                // PROTECTED: Re-enforce main volume colormap after overlay processing to prevent interference
                if (mainIsNifti && mainVol) {
                    // Only apply to the main volume, not overlays
                    if (mainVol.id !== nv.volumes[overlayStartIndex]?.id) {
                        nv.setColormap(mainVol.id, colorMapJs);
                        console.log('Re-applied main volume colormap after overlay processing');
                    }
                }

                // Honor requested slice type
                const sliceType = actualSliceType;
                console.log('Setting slice type to:', sliceType);
                nv.setSliceType(sliceType);
                
                // Configure view options based on slice type
                if (sliceType === 3) {
                    // Multiplanar view with 4 panes
                    console.log('Configuring for Multiplanar view');
                    nv.opts.multiplanarShowRender = true;
                    nv.opts.multiplanarForceRender = true;
                    nv.opts.showCrosshairs = true;
                    nv.opts.show3Dcrosshair = true;
                    nv.opts.isOrientCube = false;
                    nv.opts.isRuler = false;
                } else if (sliceType === 4) {
                    // 3D Render mode - full 3D view
                    console.log('Configuring for 3D Render view');
                    nv.opts.multiplanarShowRender = false;
                    nv.opts.multiplanarForceRender = false;
                    nv.opts.showCrosshairs = false;
                    nv.opts.show3Dcrosshair = true;
                    nv.opts.isOrientCube = false;
                    nv.opts.isRuler = false;
                    nv.opts.isRadiologicalConvention = false;
                } else {
                    // Single view modes (0, 1, 2)
                    console.log('Configuring for Single view mode');
                    nv.opts.multiplanarShowRender = false;
                    nv.opts.multiplanarForceRender = false;
                    nv.opts.showCrosshairs = false;
                    nv.opts.show3Dcrosshair = false;
                }
                
                nv.drawScene();
                
                // Simple final step: just ensure 3D render mode if needed
                setTimeout(() => {
                    // Force 3D render mode if slice type is 4
                    if (sliceType === 4) {
                        console.log('Final: Ensuring 3D render mode');
                        nv.setSliceType(4);
                        nv.opts.multiplanarShowRender = false;
                        nv.opts.multiplanarForceRender = false;
                        nv.opts.showCrosshairs = false;
                        nv.opts.show3Dcrosshair = true;
                        nv.drawScene();
                    }
                }, 500);

                

            }).catch((error) => {
                console.error('Error loading volumes:', error);
                console.error('Volume list that failed:', volumeList);
                console.error('Error details:', {
                    message: error.message,
                    stack: error.stack,
                    name: error.name
                });

                // Try to provide more helpful error information
                if (error.message && error.message.includes('fetch')) {
                    console.error('Network error - check if image server is running and file exists');
                } else if (error.message && error.message.includes('parse')) {
                    console.error('File parsing error - check if file is valid NIfTI format');
                } else {
                    console.error('Unknown error during volume loading');
                }
            });
            }
            
            // Start the process
            waitForColormapAndProceed();
        }
    </script>
</body>
</html>
