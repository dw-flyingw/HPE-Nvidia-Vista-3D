<!DOCTYPE html>
<!-- Cache bust: 2024-01-15-15:20:00 - LABEL COLORS FIX -->
<html>
<head>
    <meta charset="utf-8">
    <style>
        body, html { margin: 0; padding: 0; width: 100%; height: 100%; overflow: hidden; }
        #niivue-canvas { width: 100%; height: 100%; display: block; pointer-events: auto; }
        
        /* Fix for preventOverflow modifier warning */
        .streamlit-container {
            overflow: visible !important;
        }
        
        /* Ensure proper positioning context */
        [data-popper-placement] {
            position: relative !important;
        }
    </style>
</head>
<body>
    <canvas id="niivue-canvas"></canvas>
    
    <!-- Hidden elements to store JSON data safely -->
    <div id="volume-list-data" style="display: none;">{{ volume_list_js|safe }}</div>
    <div id="overlay-colors-data" style="display: none;">{{ overlay_colors_js|safe }}</div>
    <div id="label-colors-data" style="display: none;">{{ label_colors_js|safe }}</div>
    
    <!-- Hidden elements for template variables -->
    <div id="main-is-nifti" style="display: none;">{{ main_is_nifti }}</div>
    <div id="color-map-js" style="display: none;">{{ color_map_js|safe }}</div>
    <div id="nifti-gamma" style="display: none;">{{ nifti_gamma }}</div>
    <div id="nifti-opacity" style="display: none;">{{ nifti_opacity }}</div>
    <div id="window-center" style="display: none;">{{ window_center }}</div>
    <div id="window-width" style="display: none;">{{ window_width }}</div>
    <div id="overlay-start-index" style="display: none;">{{ overlay_start_index }}</div>
    <div id="actual-slice-type" style="display: none;">{{ actual_slice_type }}</div>
    <div id="segment-opacity" style="display: none;">{{ segment_opacity }}</div>
    <script>
        {{ niivue_lib_content|safe }}
    </script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pako/2.1.0/pako.min.js"></script>
    <script>
        // Set the image server URL for the colormap manager
        window.IMAGE_SERVER_URL = '{{ image_server_url }}';
        console.log('=== NEW VERSION LOADED - Cache cleared ===');
        console.log('Image server URL set to:', window.IMAGE_SERVER_URL);
    </script>
    <script>
        {{ colormap_manager_content|safe }}
    </script>
    <script>
        if (typeof niivue === 'undefined') {
            console.error('Niivue library not loaded!');
        } else {
            console.log('ðŸŽ¨ðŸŽ¨ðŸŽ¨ LABEL COLORS VERSION LOADED ðŸŽ¨ðŸŽ¨ðŸŽ¨');
            console.log('=== FIXED VERSION: Using custom label colors colormap ===');
            console.log('NiiVue library loaded successfully');

            const nv = new niivue.Niivue({
                isColorbar: false,
                loadingText: 'loading ...',
                dragAndDropEnabled: false,
                isResizeCanvas: true,
                crosshairWidth: 1,
                crosshairColor: [1, 0, 0, 1],
                backColor: [0, 0, 0, 1]
            });
            nv.attachTo('niivue-canvas');

            // Safely load template variables using hidden elements
            let volumeList = [];
            let overlayColors = [];
            let labelColors = [];
            try {
                const volumeListElement = document.getElementById('volume-list-data');
                const overlayColorsElement = document.getElementById('overlay-colors-data');
                const labelColorsElement = document.getElementById('label-colors-data');
                if (volumeListElement && volumeListElement.textContent) {
                    volumeList = JSON.parse(volumeListElement.textContent);
                }
                if (overlayColorsElement && overlayColorsElement.textContent) {
                    overlayColors = JSON.parse(overlayColorsElement.textContent);
                }
                if (labelColorsElement && labelColorsElement.textContent) {
                    labelColors = JSON.parse(labelColorsElement.textContent);
                }
            } catch (e) {
                console.error('Error parsing template data:', e);
            }
            
            // Safely load other template variables
            let mainIsNifti = true;
            // Map our names to Niivue built-ins when needed
            function normalizeMainColormapName(name) {
                if (!name) return 'gray';
                const n = String(name).replaceAll('"','').trim().toLowerCase();
                if (n === 'grayscale') return 'gray';
                // Known built-ins for this Niivue build
                const builtins = new Set(['gray','jet','hot','viridis','plasma','inferno','magma','hsv','turbo','bone']);
                if (builtins.has(n)) return n;
                return n; // allow custom names as-is
            }
            let colorMapJs = 'gray';
            let niftiGamma = 1.0;
            let niftiOpacity = 1.0;
            let windowCenter = 0;
            let windowWidth = 1000;
            let overlayStartIndex = 1;
            let actualSliceType = 3;
            let segmentOpacity = 0.5;
            
            try {
                const mainIsNiftiElement = document.getElementById('main-is-nifti');
                const colorMapJsElement = document.getElementById('color-map-js');
                const niftiGammaElement = document.getElementById('nifti-gamma');
                const niftiOpacityElement = document.getElementById('nifti-opacity');
                const windowCenterElement = document.getElementById('window-center');
                const windowWidthElement = document.getElementById('window-width');
                const overlayStartIndexElement = document.getElementById('overlay-start-index');
                const actualSliceTypeElement = document.getElementById('actual-slice-type');
                const segmentOpacityElement = document.getElementById('segment-opacity');
                
                if (mainIsNiftiElement && mainIsNiftiElement.textContent) {
                    mainIsNifti = mainIsNiftiElement.textContent.toLowerCase() === 'true';
                }
                if (colorMapJsElement && colorMapJsElement.textContent) {
                    colorMapJs = normalizeMainColormapName(colorMapJsElement.textContent);
                }
                if (niftiGammaElement && niftiGammaElement.textContent) {
                    niftiGamma = parseFloat(niftiGammaElement.textContent) || 1.0;
                }
                if (niftiOpacityElement && niftiOpacityElement.textContent) {
                    niftiOpacity = parseFloat(niftiOpacityElement.textContent) || 1.0;
                }
                if (windowCenterElement && windowCenterElement.textContent) {
                    windowCenter = parseFloat(windowCenterElement.textContent) || 0;
                }
                if (windowWidthElement && windowWidthElement.textContent) {
                    windowWidth = parseFloat(windowWidthElement.textContent) || 1000;
                }
                if (overlayStartIndexElement && overlayStartIndexElement.textContent) {
                    overlayStartIndex = parseInt(overlayStartIndexElement.textContent) || 1;
                }
                if (actualSliceTypeElement && actualSliceTypeElement.textContent) {
                    actualSliceType = parseInt(actualSliceTypeElement.textContent) || 3;
                }
                if (segmentOpacityElement && segmentOpacityElement.textContent) {
                    segmentOpacity = parseFloat(segmentOpacityElement.textContent) || 0.5;
                }
            } catch (e) {
                console.error('Error parsing template variables:', e);
            }
            
            console.log('Prepared volumeList:', volumeList);
            console.log('Overlay colors:', overlayColors);
            console.log('Label colors:', labelColors);
            console.log('Label colors count:', labelColors.length);
            if (labelColors.length > 0) {
                console.log('First label color:', labelColors[0]);
            }
            if (!Array.isArray(volumeList) || volumeList.some(v => !v || typeof v.url !== 'string')) {
                console.error('Invalid volumeList shape. Expected [{ url: string }, ...]. Got:', volumeList);
            }

            // We'll create our own custom colormap from the label colors
            // No need to load the external vista3d_voxels colormap
            async function loadVista3dColormap() {
                console.log('âœ… Skipping external colormap loading - using custom label colors instead');
                return true;
            }
            
            // Helper function to get label ID range
            function getLabelIdRange() {
                let minLabelId = 0;
                let maxLabelId = 0;
                if (labelColors && labelColors.length > 0) {
                    labelColors.forEach(labelColor => {
                        if (typeof labelColor.id === 'number') {
                            minLabelId = Math.min(minLabelId, labelColor.id);
                            maxLabelId = Math.max(maxLabelId, labelColor.id);
                        }
                    });
                }
                return { minLabelId, maxLabelId };
            }
            
            // Wait for colormap to load before proceeding
            function waitForColormapAndProceed() {
                loadVista3dColormap().then((loaded) => {
                    if (loaded) {
                        console.log('Using loaded vista3d_voxels colormap');
                    } else {
                        console.warn('Using fallback colormap - vista3d_voxels not available');
                    }
                    proceedWithColormap();
                });
            }
            
            function proceedWithColormap() {
                console.log('=== NEW VERSION: Using custom label colors colormap ===');
                console.log('Proceeding with colormap application...');
                
                // Register the custom label colors colormap first
                if (labelColors && Array.isArray(labelColors) && labelColors.length > 0) {
                    console.log('ðŸŽ¨ Registering custom label colors colormap from', labelColors.length, 'label colors');
                    
                    // Find the maximum label ID to determine array size
                    let maxId = 0;
                    labelColors.forEach(labelColor => {
                        if (typeof labelColor.id === 'number' && labelColor.id > maxId) {
                            maxId = labelColor.id;
                        }
                    });
                    
                    const colormapSize = maxId + 1; // Use exact size needed
                    const R = new Array(colormapSize).fill(0);
                    const G = new Array(colormapSize).fill(0);
                    const B = new Array(colormapSize).fill(0);
                    const A = new Array(colormapSize).fill(0);
                    const labels = new Array(colormapSize).fill('');
                    
                    // Set background (label 0) to be transparent
                    labels[0] = 'Background';
                    R[0] = 0;
                    G[0] = 0;
                    B[0] = 0;
                    A[0] = 0; // Transparent background
                    
                    // Fill colormap from label colors
                    labelColors.forEach(labelColor => {
                        const id = labelColor.id;
                        if (typeof id === 'number' && id >= 0 && id < colormapSize && labelColor.color) {
                            const color = labelColor.color;
                            R[id] = color[0] || 0;
                            G[id] = color[1] || 0;
                            B[id] = color[2] || 0;
                            A[id] = 255;
                            labels[id] = labelColor.name || `Label_${id}`;
                        }
                    });
                    
                    const customColormap = { R, G, B, A, labels };
                    
                    // Register the custom colormap with NiiVue
                    try {
                        nv.addColormap('vista3d_label_colors', customColormap);
                        console.log('âœ… Custom label colors colormap registered successfully');
                        console.log('ðŸ“Š Custom colormap details:', {
                            size: colormapSize,
                            labelCount: labelColors.length,
                            maxId: maxId,
                            sampleLabels: labels.slice(0, 10),
                            sampleColors: {
                                colon: { id: 62, color: [R[62], G[62], B[62]] },
                                liver: { id: 1, color: [R[1], G[1], B[1]] }
                            }
                        });
                    } catch (e) {
                        console.error('Failed to register custom label colors colormap:', e);
                    }
                } else {
                    console.warn('No label colors available for custom colormap');
                }
                
                // Check what colormaps are available
                console.log('Colormaps registered in NiiVue:', nv.getColormapNames ? nv.getColormapNames() : 'getColormapNames not available');
                
                // Prime overlays to prevent initial grayscale draw: pre-assign LUT and zero opacity
                try {
                    for (let i = overlayStartIndex; i < volumeList.length; i++) {
                        const overlayIndex = i - overlayStartIndex;
                        const isAll = overlayColors[overlayIndex]?.is_all_segmentation === true;
                        if (!volumeList[i]) continue;
                        if (isAll) {
                            // Now we can use the custom colormap since it's registered
                            volumeList[i].colormap = 'vista3d_label_colors';
                        } else {
                            // Individual overlays will be assigned specific colormap later
                            volumeList[i].colormap = 'vista3d_label_colors';
                        }
                        volumeList[i].opacity = 0.0;
                    }
                } catch (e) { console.warn('Could not prime overlay volume entries:', e); }

                // Proceed with volume loading
                loadVolumes();
            }

            function loadVolumes() {
                nv.loadVolumes(volumeList).then(() => {
                console.log('Volumes loaded successfully');
                const hasVolumes = nv.volumes.length > 0;
                const mainVol = hasVolumes ? nv.volumes[0] : null;

                if (mainIsNifti && mainVol) {
                    // MAIN VOLUME COLORMAP APPLICATION - DO NOT MODIFY WITHOUT CAREFUL TESTING
                    try { nv.setColormap(mainVol.id, colorMapJs); } catch (e) { console.warn('Fallback to gray, unknown colormap:', colorMapJs); try { nv.setColormap(mainVol.id, 'gray'); } catch (_) {} }
                    nv.setGamma(niftiGamma);
                    mainVol.opacity = niftiOpacity;

                    // Apply CT windowing settings
                    const windowCenterValue = windowCenter;
                    const windowWidthValue = windowWidth;
                    const windowMin = windowCenterValue - windowWidthValue / 2;
                    const windowMax = windowCenterValue + windowWidthValue / 2;

                    // Set the volume's display range for proper CT windowing
                    mainVol.cal_min = windowMin;
                    mainVol.cal_max = windowMax;

                    console.log('Applied CT windowing - Center:', windowCenter, 'Width:', windowWidth, 'Range:', windowMin, 'to', windowMax);
                }

                // Apply individual colors to overlays
                if (nv.volumes.length > overlayStartIndex) {
                    for (let i = overlayStartIndex; i < nv.volumes.length; i++) {
                        const overlayVol = nv.volumes[i];
                        // Set opacity to 50% for Single View mode, otherwise use slider value
                        const isSingleView = actualSliceType !== 3 && actualSliceType !== 4;
                        overlayVol.opacity = isSingleView ? 0.5 : segmentOpacity;

                        // Get the corresponding overlay color info
                        const overlayIndex = i - overlayStartIndex;

                        // Check if this is the "all segmentation" mode
                        if (overlayIndex < overlayColors.length && overlayColors[overlayIndex].is_all_segmentation) {
                            console.log('=== ALL SEGMENTATION OVERLAY DETECTED ===');
                            console.log('Overlay ID:', overlayVol.id);
                            console.log('Overlay URL:', overlayColors[overlayIndex].url);
                            
                            // The colormap is already registered and applied via volume list priming
                            // Just need to configure the display parameters
                            console.log('ðŸŽ¯ ALL VOXELS MODE: Configuring overlay display parameters');
                            
                            // Set cal_min and cal_max for label LUT
                            try {
                                const { minLabelId, maxLabelId } = getLabelIdRange();
                                overlayVol.cal_min = minLabelId;
                                overlayVol.cal_max = maxLabelId;
                                console.log('ðŸŽ¯ ALL VOXELS: Set cal_min/max for label LUT', overlayVol.cal_min, overlayVol.cal_max, 'Label range:', minLabelId, 'to', maxLabelId);
                                console.log('ðŸŽ¯ ALL VOXELS: Volume details:', {
                                    id: overlayVol.id,
                                    cal_min: overlayVol.cal_min,
                                    cal_max: overlayVol.cal_max,
                                    colormap: overlayVol.colormap
                                });
                            } catch (e) { console.warn('Unable to set cal range for labels', e); }

                            // ALL VOXELS MODE: Ensure overlay is visible after colormap application
                            overlayVol.opacity = segmentOpacity; // Force opacity for All Voxels mode
                            console.log('ðŸŽ¯ ALL VOXELS: Set opacity to', segmentOpacity, 'for overlay:', overlayVol.id);
                            
                            // ALL VOXELS MODE: Ensure the volume is marked as visible for all view modes
                            overlayVol.visible = true;
                            overlayVol.visible3D = true;
                            overlayVol.visibleMultiplanar = true;
                            overlayVol.visibleAxial = true;
                            overlayVol.visibleCoronal = true;
                            overlayVol.visibleSagittal = true;
                            console.log('ðŸŽ¯ ALL VOXELS: Set visibility flags for overlay:', overlayVol.id, 'All view modes enabled');
                            
                            // Force a redraw to ensure the colormap is applied
                            setTimeout(() => {
                                // Double-check visibility before redraw - ensure ALL view modes are enabled
                                try {
                                    const { minLabelId, maxLabelId } = getLabelIdRange();
                                    overlayVol.cal_min = minLabelId;
                                    overlayVol.cal_max = maxLabelId;
                                } catch {}
                                overlayVol.opacity = segmentOpacity;
                                overlayVol.visible = true;
                                overlayVol.visible3D = true;
                                overlayVol.visibleMultiplanar = true;
                                overlayVol.visibleAxial = true;
                                overlayVol.visibleCoronal = true;
                                overlayVol.visibleSagittal = true;
                                nv.drawScene();
                                console.log('ðŸŽ¯ ALL VOXELS: Colormap applied and scene redrawn for overlay:', overlayVol.id, 'Opacity:', overlayVol.opacity, 'All view modes enabled');
                            }, 100);
                        } else if (overlayIndex < overlayColors.length && overlayColors[overlayIndex].color) {
                            const color = overlayColors[overlayIndex].color;
                            const labelName = overlayColors[overlayIndex].label_name;

                            // Create a custom colormap for this specific overlay
                            const customColormap = {
                                R: [0, color[0]],
                                G: [0, color[1]],
                                B: [0, color[2]],
                                A: [0, 255],
                                labels: ['Background', labelName]
                            };

                            const colormapName = `custom_${overlayIndex}`;
                            nv.addColormap(colormapName, customColormap);
                            nv.setColormap(overlayVol.id, colormapName);
                            try { overlayVol.cal_min = 0; overlayVol.cal_max = 1; } catch {}
                            console.log(`Applied custom color to overlay ${overlayIndex}: ${labelName}`, color);
                        } else {
                            // Fallback to generic segmentation colormap
                            if (typeof customSegmentationColormap !== 'undefined') {
                                nv.setColormap(overlayVol.id, 'custom_segmentation');
                                console.log('Applied custom_segmentation colormap to overlay volume (fallback):', overlayVol.id, 'Name:', overlayVol.name || 'Unnamed');
                                // Force a redraw to ensure the colormap is applied
                                setTimeout(() => {
                                    try { 
                                        const { minLabelId, maxLabelId } = getLabelIdRange();
                                        overlayVol.cal_min = minLabelId; 
                                        overlayVol.cal_max = maxLabelId; 
                                    } catch {}
                                    nv.drawScene();
                                }, 100);
                            } else {
                                console.error('Custom segmentation colormap is undefined in fallback!');
                            }
                        }
                    }
                }

                // PROTECTED: Re-enforce main volume colormap after overlay processing to prevent interference
                if (mainIsNifti && mainVol) {
                    // Only apply to the main volume, not overlays
                    if (mainVol.id !== nv.volumes[overlayStartIndex]?.id) {
                        try { nv.setColormap(mainVol.id, colorMapJs); } catch (e) { try { nv.setColormap(mainVol.id, 'gray'); } catch (_) {} }
                        console.log('Re-applied main volume colormap after overlay processing');
                        
                        // Ensure overlays remain visible after main volume processing
                        setTimeout(() => {
                            for (let i = overlayStartIndex; i < nv.volumes.length; i++) {
                                const vol = nv.volumes[i];
                                if (vol && vol.id !== mainVol.id) {
                                    // Force overlay opacity and visibility - especially for All Voxels
                                    try { 
                                        const { minLabelId, maxLabelId } = getLabelIdRange();
                                        vol.cal_min = minLabelId; 
                                        vol.cal_max = maxLabelId; 
                                    } catch {}
                                    vol.opacity = segmentOpacity;
                                    vol.visible = true;
                                    vol.visible3D = true;
                                    vol.visibleMultiplanar = true;
                                    vol.visibleAxial = true;
                                    vol.visibleCoronal = true;
                                    vol.visibleSagittal = true;
                                    
                                    // Check if this is an All Voxels overlay
                                    const isAllVoxels = overlayColors[i - overlayStartIndex]?.is_all_segmentation;
                                    if (isAllVoxels) {
                                        console.log('ðŸŽ¯ ALL VOXELS: Ensured visibility after main volume processing - Volume:', vol.id, 'Opacity:', vol.opacity, 'Visible:', vol.visible);
                                    } else {
                                        console.log('Ensured overlay visibility for volume:', vol.id, 'opacity:', vol.opacity);
                                    }
                                }
                            }
                        }, 200);
                    }
                }

                // Honor requested slice type
                const sliceType = actualSliceType;
                console.log('Setting slice type to:', sliceType);
                nv.setSliceType(sliceType);
                
                // Configure view options based on slice type
                if (sliceType === 3) {
                    // Multiplanar view with 4 panes
                    console.log('Configuring for Multiplanar view');
                    nv.opts.multiplanarShowRender = true;
                    nv.opts.multiplanarForceRender = true;
                    nv.opts.showCrosshairs = true;
                    nv.opts.show3Dcrosshair = true;
                    nv.opts.isOrientCube = false;
                    nv.opts.isRuler = false;
                } else if (sliceType === 4) {
                    // 3D Render mode - full 3D view
                    console.log('Configuring for 3D Render view');
                    nv.opts.multiplanarShowRender = false;
                    nv.opts.multiplanarForceRender = false;
                    nv.opts.showCrosshairs = false;
                    nv.opts.show3Dcrosshair = true;
                    nv.opts.isOrientCube = false;
                    nv.opts.isRuler = false;
                    nv.opts.isRadiologicalConvention = false;
                } else {
                    // Single view modes (0, 1, 2)
                    console.log('Configuring for Single view mode');
                    nv.opts.multiplanarShowRender = false;
                    nv.opts.multiplanarForceRender = false;
                    nv.opts.showCrosshairs = false;
                    nv.opts.show3Dcrosshair = false;
                }
                
                nv.drawScene();
                
                // Note: avoid re-applying overlays to prevent flash and unintended demotion to grayscale
                
                // Simple final step: just ensure 3D render mode if needed
                setTimeout(() => {
                    // Force 3D render mode if slice type is 4
                    if (sliceType === 4) {
                        console.log('Final: Ensuring 3D render mode');
                        nv.setSliceType(4);
                        nv.opts.multiplanarShowRender = false;
                        nv.opts.multiplanarForceRender = false;
                        nv.opts.showCrosshairs = false;
                        nv.opts.show3Dcrosshair = true;
                        
                        // Final check: Ensure all overlays remain visible after all rendering operations
                        for (let i = overlayStartIndex; i < nv.volumes.length; i++) {
                            const vol = nv.volumes[i];
                            if (vol && vol.id !== mainVol?.id) {
                                // Force overlay visibility - especially important for All Voxels mode
                                try { 
                                    const { minLabelId, maxLabelId } = getLabelIdRange();
                                    vol.cal_min = minLabelId; 
                                    vol.cal_max = maxLabelId; 
                                } catch {}
                                vol.opacity = segmentOpacity; // Force opacity
                                vol.visible = true; // Force visibility
                                vol.visible3D = true; // Force 3D visibility
                                vol.visibleMultiplanar = true; // Force Multiplanar visibility
                                vol.visibleAxial = true; // Force Axial visibility
                                vol.visibleCoronal = true; // Force Coronal visibility
                                vol.visibleSagittal = true; // Force Sagittal visibility
                                
                                // Check if this is an All Voxels overlay
                                const isAllVoxels = overlayColors[i - overlayStartIndex]?.is_all_segmentation;
                                if (isAllVoxels) {
                                    console.log('ðŸŽ¯ ALL VOXELS: Final visibility check - Volume:', vol.id, 'Opacity:', vol.opacity, 'Visible:', vol.visible, 'Visible3D:', vol.visible3D);
                                } else {
                                    console.log('Final overlay visibility check - Volume:', vol.id, 'Opacity:', vol.opacity, 'Visible:', vol.visible);
                                }
                            }
                        }
                        
                        nv.drawScene();
                        console.log('Final scene redraw completed with overlay visibility ensured');
                    }
                }, 500);

                

            }).catch((error) => {
                console.error('Error loading volumes:', error);
                console.error('Volume list that failed:', volumeList);
                console.error('Error details:', {
                    message: error.message,
                    stack: error.stack,
                    name: error.name
                });

                // Try to provide more helpful error information
                if (error.message && error.message.includes('fetch')) {
                    console.error('Network error - check if image server is running and file exists');
                } else if (error.message && error.message.includes('parse')) {
                    console.error('File parsing error - check if file is valid NIfTI format');
                } else {
                    console.error('Unknown error during volume loading');
                }
            });
            }
            
            // Start the process
            waitForColormapAndProceed();
        }
    </script>
</body>
</html>
